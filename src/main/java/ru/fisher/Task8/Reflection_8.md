Рефлексия на 8-е задание:  
Эталонное решение хорошо показывает как правильно использовать очереди для разделения сервиса и клиента.  
Моё решение в плане stateless на Java выполнено не так идеально,
как это показано в примере, но также состояние нигде не хранится, все поля в классах неизменяемы.

В примере состояние нигде не хранится и передается каждый раз с командой в очереди.  
ThreadRobo - некий воркер, который обрабатывает команды, получает из 
входящей очереди и передает результат в выходную очередь.  
RobotCommand - это сообщение содержащие состояние и команда на выполнение.
Использование воркеров для горизонтального масштабирования очень хорошо показывает 
как можно регулировать нагрузку на серверную часть.  
Как реализована stateless_архитектура на примере Python понятна.