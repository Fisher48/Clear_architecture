Рефлексия на 14-е задание:  

Задание выполнено почти по аналогии с примером на Python.
Моя реализация паттерна Command также показывает как можно изменять состояние робота через различные команды, которые потом применяются к конкретному роботу,
каждая операция — это отдельная команда, изменяющая состояние робота.

Команда — это отдельный класс, реализующий интерфейс Command, а состояние (RobotState) передаётся и возвращается явно.
Вместо списка логов я передаю в ConsoleCommunicator все действия робота.
Здесь есть недочет можно отделить логику коммуникатор от интерфейса Command и использовать его только в определенном типе Executor,
в зависимости от реализации и потребности конкретного робота. Ну и также можно регистрировать команды в конкретном Executor, 
а не создавать список команд, а стороне клиента и передавать уже список, но это уже вопросы реализации.
Можно легко добавить новую команду, достаточно реализовать Command и переопределить execute().

В Python-версии, как обычно), код получился короче.
Благодаря dataclass и Protocol можно описывать состояние и интерфейс команды в несколько строк.
Типизация мягче, нет избыточных конструкций, а вся логика чтения и исполнения команд выглядит компактно.
