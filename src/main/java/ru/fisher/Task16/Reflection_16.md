Рефлексия на 16-е задание Stream Processing:  
Задание выполнено верно, по аналогии с примером на питоне. Как всегда, код на питоне более компактный и грамотный.  
Плюсы примера на питоне, можно использовать несколько разных роботов передавая robotId и есть StateProjector, который восстанавливает текущее состояние робота, 
у меня это аналогично в методе applyEventToState() в EventStore.  
У нас есть команды Command, которые затем преобразуется в события-запросы RequestEvent.  
События Event которые были совершены. 
Обработчик событий простой, ничего не делает кроме как принимает и передает команду в EventStore.  
EventStore в свою очередь содержит основную логику обработки событий, в котором также происходит подписка подписчиков на события.  
Появились так называемые процессоры Event Processors и для каждой команды реализован свой процессор, в котором содержится вся бизнес-логика.
В каждом процессоре идет сразу подписка на события.
В нем вычисляется новое состояние, создается событие (как прошедшее) и после этого сохраняется в EventStore, затем вызывается метод publish
для уведомления подписчиков о событии.
Нюансы учтены, по поводу блокировки потоков, чтобы избежать состояния гонки, требуется использовать RLock вместо обычного Lock.
RLock позволит одному потоку захватывать блокировку несколько раз.